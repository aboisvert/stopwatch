---
layout: default
title: Stopwatch
---

h2. Monitor your production Scala applications.

This API can be used to determine application performance bottlenecks, user/application interactions, and application scalability. Each stopwatch gathers summary statistics such as hits, execution times (total, average, minimum, maximum, standard deviation), distribution, and simultaneous requests or threads.

h2. Basic Usage

h3. Critical Section

{% highlight scala %}
import stopwatch.Stopwatch

// A stopwatch surrounds your code,
// like a critical section
Stopwatch("test") {
  // code being timed
  doSomething()
  somethingEvenLonger()
}
{% endhighlight %}

h3. Usage for non-inlined code

Sometimes you want to measure the performance of an operation which is not emcompassed by a single code section.  You can then use the @start@ and @stop@ methods to delimit the scope of the operation.

{% highlight scala %}
val stopwatch = Stopwatch.start("test")

// and later, elsewhere in your code
stopwatch.stop()
{% endhighlight %}

This approach can also be used for languages other than Scala (e.g. Java) that may not be able to pass in a Scala closure as second argument list.

h3. Distribution Range

You can define a range on stopwatch groups (see below) to plot execution time distribution graphs.

{% highlight scala %}
import stopwatch.Stopwatch
import stopwatch.StopwatchRange

// somewhere in your code, before using the stopwatch
// distribution:  0s to 15s in 500ms intervals
Stopwatch.range = StopwatchRange(0, 15000, 500)
{% endhighlight %}

h3. Resetting statistics

You may programmatically reset the values of stopwatches if your application has multiple cycles or if you want to recalibrate after the JVM ("HotSpot compiler") has had time to optimize your code.

{% highlight scala %}
import stopwatch.Stopwatch

Stopwatch.reset("test")
{% endhighlight %}

h3. Displaying statistics

{% highlight scala %}
val stats = Stopwatch.snapshot("test")
Console.println(stats.toShortString)
Console.println(stats.toMediumString) // includes thread info
Console.println(stats.toLongString)   // includes threads + hit distribution
Console.println(stats)                // defaults to medium string
{% endhighlight %}

h2. Advanced Use Cases

h3. Grouping

You can define multiple stopwatch groups, each having their own distribution range.   Groups are also useful for visual organization and to avoid name clashes.

{% highlight scala %}
import stopwatch.Stopwatch
import stopwatch.StopwatchGroup

val incomingRequests = new StopwatchGroup("Incoming Requests")
incomingRequest.range = StopwatchRange(0, 30000, 1000)

incomingRequests(clientId) {
  // code being timed
  doStuffForClient()
}
{% endhighlight %}

The singleton @Stopwatch@ object that has been used in the above examples is the default group.

h2. Web Interface

!images/stopwatches-thumbnail.jpg!:images/stopwatches.png

!images/distribution-thumbnail.jpg!:images/distribution.png

h3. TODO's

* Improve web UI
* Use System.nanoTime() instead of System.currentTimeMillis() to measure lapsed time
* Add Stopwatch.error() method to measure errors and exceptions for operations and code blocks
* Add doc section detailing performance
* Add reset button(s) on web UI
* Prettify the distribution graph.  Colors are ugly.

h2. Target platform

* Scala 2.7.4+ / 2.8+  (source compatible)
* JVM 1.5+

h2. License

Copyright (C) 2009-2010 by Alex Boisvert.

Stopwatch is is licensed under the terms of the "Apache Software License v2.0":http://www.apache.org/licenses/LICENSE-2.0.html
